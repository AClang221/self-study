"""
马的遍历  洛谷p1443
    题目描述
    有一个 n*m 的棋盘，在某个点 (x, y) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。
输入格式:
        输入只有一行四个整数，分别为 $n, m, x, y$。

输出格式:
        一个 n*m 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 -1）。

样例 #1
        样例输入 #1
```
3 3 1 1
```
样例输出 #1
```
0    3    2
3    -1   1
2    1    4
```
"""



"""
解题思路bfs
    首先由题可知不能走到的位置为-1，那么我们可以建立一个与棋盘等大的列表将每个列表元素设置为-1
    
    然后再新建一个列表存放当前位置（此列表的功能与栈相同），通过马可走的八个方向进行遍历
    
    将符合要求的点依次放入列表中，然后依次取出符合要求的点的坐标进行二次判断，直到列表中没有坐标为止
    
    然后输出结果
"""
# 注意：题目中的n,m大的棋盘指的是n行m列   x,y则表示的是第x行的第y个位置为初始起点，与数学中的坐标轴不同
n,m,x,y = map(int,input().split())
# 创建名为graph的图与棋盘一一对应
graph = [[-1 for i in range(m)]for j in range(n)]
# 创建方向
f=[(1,2),(-1,-2),(1,-2),(-1,2),(2,1),(-2,1),(2,-1),(-2,-1)]


def bfs():
    # 将初始位置进行设置
    graph[x-1][y-1]=0
    # 创建一个栈用于存放要走的点
    queue = []
    # 将初始的位置添加到栈中
    queue.append((x-1,y-1))
    # while 语句进行遍历直到全部遍历完结束
    while queue:
        x1,y1=queue.pop(0)
        for n_x,n_y in f:
            # 利用自定义函数进行判断走到的位置是否合规
            if pd(n_x+x1,n_y+y1):
                if graph[n_x+x1][n_y+y1]==-1:
                    graph[n_x+x1][n_y+y1]=graph[x1][y1]+1
                    queue.append((n_x+x1,n_y+y1))


# 判断函数
def pd(x,y):
    return 0 <= x < n and 0 <= y < m


bfs()  # 用来调用bfs函数

# 程序的输出
for i in range(n):
    for j in range(m):
        print(graph[i][j],end=" ")
    print()
